from time import sleep

from istari_digital_client import Client, Configuration, Job, Model
from istari_digital_client.models import JobStatusName
from shared.constants import REG_URL, REG_AUTH_TOKEN


job_list = []

def get_client():
  configuration = Configuration(
      registry_url=REG_URL,
      registry_auth_token=REG_AUTH_TOKEN)

  return Client(config = configuration)


def submit_job(model_id: str,
               function: str,
               tool_name: str,
               tool_ver: str = None,
               params_file: str = None) -> Job:
  client = get_client()
  job =  client.add_job(model_id,
                        function = function,
                        tool_name = tool_name,
                        tool_version = tool_ver,
                        parameters_file = params_file)
  job_list.append(job.id)
  return job


def wait_for_job(job) -> Job:
  client = get_client()
  empty_str = ' ' * 64
  while not job.status.name in [JobStatusName.COMPLETED, 
                                JobStatusName.FAILED]:
    sleep(1)
    job = client.get_job(job.id)
    print(empty_str, end="\r")
    job_stat = format_str(job.status.name, 1)
    print(f"Job Status: {job_stat}", end="\r")

  if job.id in job_list:
    job_list.remove(job.id)

  print(empty_str, end="\r")
  return job


def wait_for_all_jobs():
  client = get_client()
  for job_id in job_list:
    job = client.get_job(job_id)
    wait_for_job(job)


def get_latest_revision(model_id: str) -> str:
  client = get_client()
  mod = client.get_model(model_id)
  mod_revs = mod.file.revisions
  ret_rev = None
  for mod_rev in mod_revs:
    if ret_rev == None or ret_rev.created < mod_rev.created:
      ret_rev = mod_rev

  return ret_rev.id
  

def wait_for_new_version(model_id: str) -> Model:
  client = get_client()
  empty_str = ' ' * 64
  mod = client.get_model(model_id)
  revs = mod.file.revisions
  mod_name = revs[0].display_name
  latest_rev = revs[-1]
  rev_count = len(revs)
  while True:
    print(empty_str, end="\r")
    print(f"Polling for model updates: {mod_name}",
          end="\r")
    sleep(5)
    mod = client.get_model(model_id)
    revs = mod.file.revisions
    new_rev_count = len(revs)
    if new_rev_count != rev_count:
      latest_rev = revs[-1]
      break

  print(empty_str, end="\r")
  print(f"Model update detected: {mod_name}")
  return latest_rev


def download_artifact_orig(model_id: str,
                      artifact_name: str,
                      dest_file: str = None):
  client = get_client()
  art = None
  pg_idx = 1
  while True:
    art_list = client.list_model_artifacts(model_id,
                                           page = pg_idx)
    art_items = art_list.items
    if len(art_items) == 0:
      break
    
    for itm in art_items:
      if itm.name == artifact_name:
        art = itm
        break

    if art is not None: break
    pg_idx += 1

  if art is None:
    raise FileNotFoundError(f"Artifact not found: {artifact_name}")
  else:
    if dest_file is None:
      dest_file = artifact_name
    with open(dest_file, 'wb') as fout:
      fout.write(art.read_bytes())


def download_artifact_data(model_id: str,
                           artifact_name: str) -> bytes:
  client = get_client()
  mod = client.get_model(model_id)
  mod_rev_id = mod.file.revisions[-1].id

  pg_idx = 1
  while True:
    art_list = client.list_model_artifacts(model_id,
                                           page = pg_idx)
    arts = art_list.items
    if len(arts) == 0:
      break
    
    # Find artifact with name matching artifact_name and generated by the latest
    # version of the model
    for art in arts:
      if art.name == artifact_name:
        for art_rev in art.revisions:
          for art_rev_src in art_rev.sources:
            if art_rev_src.revision_id == mod_rev_id:
              return art_rev.read_bytes()

    pg_idx += 1

  raise FileNotFoundError(f"Artifact not found: {artifact_name}")


def download_artifact(model_id: str,
                      artifact_name: str,
                      dest_file: str = None) -> None:
  """
  Downloads the artifact associated with the latest version of the model.

  Throws FileNotFoundError if the artifact is not found.
  """
  art_bytes = download_artifact_data(model_id,
                                     artifact_name)
  if dest_file is None:
    dest_file = artifact_name
  with open(dest_file, 'wb') as fout:
    fout.write(art_rev.read_bytes())


def get_input(msg: str,
              allowed_resps: list[str] = None) -> str:
  while True:
    ans = input(msg).lower()
    if allowed_resps is None or ans in allowed_resps:
      break
    else:
      print('Invalid response')

  return ans


def format_str(text: str,
               color: int,
               effect1: int = -1,
               effect2: int = -1):
  FMT_PREFIX = '\033['
  fmt_str = f"{FMT_PREFIX}{color}"
  if effect1 >= 0:
    fmt_str += f";{effect1}"
  if effect2 >= 0:
    fmt_str += f";{effect2}"

  return f"{fmt_str}m{text}{FMT_PREFIX}0m"

